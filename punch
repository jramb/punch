#!/bin/bash
## Punch! - CLI interface to Emacs ORG-mode files for clocks 2014 by jramb
## Background: I am a Vimmer, but there is one thing that rocks about Emacs: the ORG mode
## This script reduces my need to fire up Emacs to once a month when I assemble my
## Time reports...
########################

shopt -s nocasematch   # case insensitve matching

if [[ ! -f "$CLOCKFILE" ]]; then
  echo "You need to set the environmen variable CLOCKFILE (pointing to an existing file)"
  exit 2
fi

copyfile="${CLOCKFILE}.copy"
backupfile="${CLOCKFILE}.backup-$(date +%Y%m%d)"
[[ -f "$copyfile" ]] && rm "$copyfile"

backIFS=$IFS
IFS=
verbose=

date_match="[0-9]{4}-[0-9]{2}-[0-9]{2}"
time_match="[0-9]{1,2}:[0-9]{2}"
duration_match="-?[0-9]+:[0-9]{2}"
date_time_match="($date_match [[:alpha:]]{1,3} $time_match)"
clock_match="CLOCK: \[$date_time_match\](--\[$date_time_match\]( =>[[:space:]]*($duration_match)))?"
struct_match='^((\*+)[[:space:]]+)(.*)$'

usage() {
  cat << EOF_USAGE
usage: $(basename $0) <command>
  2014 by jramb

commands:
  h[elp]      Show this message
  ls          lists tasks in clock filej
  in <task>   Check in (start timer) for task (also stops all other timers)
  out         Check out (stops ALL timers)

You need to set the environmen variable CLOCKFILE (pointing to an existing file)
EOF_USAGE
}

cmd_structure() {
  local line
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $struct_match ]]; then
      echo "$line"
    fi
  done;
}

# CLOCK: [2013-06-19 Wed 09:10]--[2013-06-19 Wed 19:10] => 10:00
#         1                    2  3                    4   5
cmd_times() {
  local line
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $clock_match ]]; then
      echo "$line"
    fi
  done;
}

to_epoc() {
  echo "$(date -d "$1" "+%s")"
}

make_backup() {
  [[ ! -f "$backupfile" ]] && mv "$CLOCKFILE" "$backupfile"
}

finish_time() {
  now_is="$(date "+%F %a %R")"
  elapsed=$(( $(to_epoc "$now_is") - $(to_epoc "${BASH_REMATCH[1]}") ))
  let "elapsed_minutes=elapsed/60"
  if (( elapsed_minutes < 0 )); then
    let "elapsed_minutes = -elapsed_minutes"
    sign=-
  fi
  let "elapsed_hours=elapsed_minutes/60"
  let "elapsed_minutes -= elapsed_hours * 60"
  as_time=$(printf "%2s:%02d" "$sign$elapsed_hours" $elapsed_minutes)
  echo "CLOCK: [${1}]--[$now_is] => $as_time"
}

running() {
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $struct_match ]]; then
      indent=${#BASH_REMATCH[1]} # indent size
      current=${BASH_REMATCH[3]}
    fi
    if [[ "$line" =~ $clock_match ]]; then
      if [[ ! -n "${BASH_REMATCH[2]}" ]]; then
        echo "$current running" >&2
        line=$(printf "%${indent}s%s\n" '' $(finish_time "${BASH_REMATCH[1]}"))
        echo "$line [RUNNING]" >&2
      fi
    fi
  done;
}

check_out() {
  {
    while read line
    do
      # check if current line is a structure line (starting with an asterix)
      if [[ "$line" =~ $struct_match ]]; then
        indent=${#BASH_REMATCH[1]} # indent size
        current=${BASH_REMATCH[3]}
      fi
      if [[ ! -z "$line" ]]; then
        if [[ "$line" =~ $clock_match && ! -n "${BASH_REMATCH[2]}" ]]; then
          line=$(printf "%${indent}s%s\n" '' $(finish_time "${BASH_REMATCH[1]}"))
          echo "$current checked out" >&2
          echo "$line" >&2
        fi
        echo "$line"
      fi
    done 
  } < "$CLOCKFILE" >"$copyfile"
  make_backup && mv -f "$copyfile" "$CLOCKFILE"
}

check_in() {
  section="$1"
  if [[ -z "$section" ]]; then
    echo "Need a section to check in"
    cmd_structure
    exit 2
  fi
  {
    while read line
    do
      # check if current line is a structure line (starting with an asterix)
      if [[ "$line" =~ $struct_match ]]; then
        indent=${#BASH_REMATCH[1]} # indent size
        current=${BASH_REMATCH[3]}
        if [[ $current =~ "$section" && -z "$now_is" ]]; then
          now_is="$(date "+%F %a %R")"
          echo "$line" # original
          line=$(printf "%${indent}s%s\n" '' "CLOCK: [$now_is]")
          echo "$line" # the new one
          echo "$current checked in" >&2
          echo "$line" >&2
          unset line
        fi
      fi
      if [[ -v line ]]; then
        if [[ "$line" =~ $clock_match && ! -n "${BASH_REMATCH[2]}" ]]; then
          line=$(printf "%${indent}s%s\n" '' $(finish_time "${BASH_REMATCH[1]}"))
          echo "$current checked out" >&2
          echo "$line" >&2
        fi
        echo "$line"
      fi
    done 
    #echo "$current --> $now_is" >&2
  } < "$CLOCKFILE" >"$copyfile"
  make_backup && mv -f "$copyfile" "$CLOCKFILE"
}


edit() {
  if [[ ! -z "$EDITOR" ]]; then
    $EDITOR $CLOCKFILE
  fi
}



while true; do
  case "$1" in
    st*|ls)
      cmd_structure
      ;;
    ti*)
      cmd_times
      ;;
    ed*)
      edit
      ;;
    sh*) # show
      cat "$CLOCKFILE"
      ;;
    in)
      check_in $2
      ;;
    diff)
      if [[ -f "$backupfile" ]]; then
        diff "$backupfile" "$CLOCKFILE"
      else
        echo 'No changes yet'
      fi
      ;;
    out)
      check_out
      ;;
    ru*)
      running
      ;;
    h*|*)
      usage
      exit 1
      ;;
  esac
  shift
  exit 0
done

