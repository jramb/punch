#!/bin/bash
## Punch! - CLI interface to Emacs ORG-mode files for clocks 2014 by jramb
## Background: I am a Vimmer, but there is one thing that rocks about Emacs: the ORG mode
## This script reduces my need to fire up Emacs to once a month when I assemble my
## Time reports...
########################

#set -x
set -e
set -u

shopt -s nocasematch   # case insensitve matching

if [[ ! -f "$CLOCKFILE" ]]; then
  echo "You need to set the environmen variable CLOCKFILE (pointing to an existing file)"
  exit 2
fi

copyfile="${CLOCKFILE}.copy"
backupfile="${CLOCKFILE}.backup-$(date +%Y%m%d)"
[[ -f "$copyfile" ]] && rm "$copyfile"

backIFS=$IFS
IFS=
verbose=

date_match="[0-9]{4}-[0-9]{2}-[0-9]{2}"
time_match="[0-9]{1,2}:[0-9]{2}"
duration_match="-?[0-9]+:[0-9]{2}"
date_time_match="($date_match [[:alpha:]]{1,3} $time_match)"
clock_match="CLOCK: \[$date_time_match\](--\[$date_time_match\]( =>[[:space:]]*($duration_match)))?"
struct_match='^((\*+)[[:space:]]+)(.*)$'

usage() {
  cat << EOF_USAGE
'punch' 2014 by jramb
---------------------
Usage: $(basename $0) <command> [<opt>]

commands:
  h[elp]      Show this message
  ls          lists tasks in clock filej
  in <task>   Check in (start timer) for task (also stops all other timers)
  out         Check out (stops ALL timers)

You need to set the environmen variable CLOCKFILE (pointing to an existing file)
EOF_USAGE
}

cmd_structure() {
  local line
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $struct_match ]]; then
      echo "$line"
    fi
  done;
}

# CLOCK: [2013-06-19 Wed 09:10]--[2013-06-19 Wed 19:10] => 10:00
#         1                    2  3                    4   5
cmd_times() {
  local line
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $clock_match ]]; then
      echo "$line"
    fi
  done;
}

to_epoc() {
  echo "$(date -d "$1" "+%s")"
}

make_backup() {
  [[ ! -f "$backupfile" ]] && mv "$CLOCKFILE" "$backupfile"
}


analyze() {
  section="$1"
  section_found=
  last_time=0
  is_running=0
  cat "$CLOCKFILE" |
  {
    while read line; do
      if [[ "$line" =~ $struct_match ]]; then
        current=${BASH_REMATCH[3]}
        if [[ ! -z "$section" ]]; then
          if [[ $current =~ "$section" ]]; then
            if [[ -z "$section_found" ]]; then
              section_found="$current"
            else
              echo "ERROR: Duplicate section match: '$section_found' and '$current'" >&2
              exit 99 # Found duplicate structure
            fi
          fi
        fi
      fi
      if [[ "$line" =~ $clock_match ]]; then
        this_time=$(to_epoc ${BASH_REMATCH[1]})
        if (( this_time > last_time )); then
          last_time=$this_time
        fi
        if [[ ! -n "${BASH_REMATCH[2]}" ]]; then
          is_running=1
        fi
      fi
    done 
    echo "$last_time:$is_running:$section_found"
  }
}

duration_since() {
  local sign=
  now_is=${2:- $(date +%s)}
  elapsed=$(( $now_is - $(to_epoc "$1") ))
  let "elapsed_minutes=elapsed/60"
  if (( elapsed_minutes < 0 )); then
    let "elapsed_minutes = -elapsed_minutes"
    sign=-
  fi
  let "elapsed_hours=elapsed_minutes/60"
  let "elapsed_minutes -= elapsed_hours * 60"
  as_time=$(printf "%s:%02d" "$sign$elapsed_hours" $elapsed_minutes)
  echo "$as_time"
}

conclude_time() {
  now_is="$(date "+%F %a %R")"
  duration="$(duration_since "$1" $(to_epoc "$now_is"))"
  echo "CLOCK: [${1}]--[$now_is] => $(printf "%5s" "$duration")"
}

running() {
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $struct_match ]]; then
      indent=${#BASH_REMATCH[1]} # indent size
      current=${BASH_REMATCH[3]}
    fi
    if [[ "$line" =~ $clock_match ]]; then
      if [[ ! -n "${BASH_REMATCH[2]}" ]]; then
        echo "$current running" >&2
        line=$(printf "%${indent}s%s\n" '' $(conclude_time "${BASH_REMATCH[1]}"))
        echo "$line [RUNNING]" >&2
      fi
    fi
  done;
}

prompt() {
  cat "$CLOCKFILE" |
  while read line ; do
    if [[ "$line" =~ $struct_match ]]; then
      current=${BASH_REMATCH[3]}
    fi
    if [[ "$line" =~ $clock_match ]]; then
      if [[ ! -n "${BASH_REMATCH[2]}" ]]; then
        echo "$current: $(duration_since "${BASH_REMATCH[1]}")\n"
      fi
    fi
  done;
}

check_out() {
  {
    while read line
    do
      # check if current line is a structure line (starting with an asterix)
      if [[ "$line" =~ $struct_match ]]; then
        indent=${#BASH_REMATCH[1]} # indent size
        current=${BASH_REMATCH[3]}
      fi
      if [[ ! -z "$line" ]]; then
        if [[ "$line" =~ $clock_match && ! -n "${BASH_REMATCH[2]}" ]]; then
          line=$(printf "%${indent}s%s\n" '' $(conclude_time "${BASH_REMATCH[1]}"))
          echo "$current checked out" >&2
          echo "$line" >&2
        fi
        echo "$line"
      fi
    done 
  } < "$CLOCKFILE" >"$copyfile"
  make_backup
  mv -f "$copyfile" "$CLOCKFILE"
}

check_in() {
  section="$1"
  check=$(analyze "$1")
  (( $? > 0 )) && return 
  if [[ -z "$section" ]]; then
    echo "Need a section to check in"
    cmd_structure
    exit 2
  fi
  {
    while read line
    do
      # check if current line is a structure line (starting with an asterix)
      if [[ "$line" =~ $struct_match ]]; then
        indent=${#BASH_REMATCH[1]} # indent size
        current=${BASH_REMATCH[3]}
        if [[ $current =~ "$section" && -z "$now_is" ]]; then
          now_is="$(date "+%F %a %R")"
          echo "$line" # original
          line=$(printf "%${indent}s%s\n" '' "CLOCK: [$now_is]")
          echo "$line" # the new one
          echo "$current checked in" >&2
          echo "$line" >&2
          unset line
        fi
      fi
      if [[ -v line ]]; then
        if [[ "$line" =~ $clock_match && ! -n "${BASH_REMATCH[2]}" ]]; then
          line=$(printf "%${indent}s%s\n" '' $(conclude_time "${BASH_REMATCH[1]}"))
          echo "$current checked out" >&2
          echo "$line" >&2
        fi
        echo "$line"
      fi
    done 
    #echo "$current --> $now_is" >&2
  } < "$CLOCKFILE" >"$copyfile"
  make_backup 
  mv -f "$copyfile" "$CLOCKFILE"
}


edit() {
  if [[ ! -z "$EDITOR" ]]; then
    $EDITOR $CLOCKFILE
  fi
}



while true; do
  case "$1" in
    str*|ls)
      cmd_structure
      ;;
    ti*)
      cmd_times
      ;;
    ed*)
      edit
      ;;
    sh*) # show
      cat "$CLOCKFILE"
      ;;
    in|sta*)
      check_in $2
      ;;
    diff)
      if [[ -f "$backupfile" ]]; then
        diff "$backupfile" "$CLOCKFILE"
      else
        echo 'No changes yet'
      fi
      ;;
    out|sto*)
      check_out
      ;;
    h*)
      usage
      exit 1
      ;;
    ru*)
      running
      ;;
    pro*)
      prompt
      exit 0
      ;;
    *)
      running
      echo "Run '$(basename "$0") help' for more info" >&2
      ;;
  esac
  shift
  exit 0
done

