// Generated by LiveScript 1.2.0
/* 2014 by J Ramb */
(function(){
  var readline, fs, os, child_process, ref$, each, map, println, pad2, startDate, clockfile, backupfile, tmpfile, dateMatch, timeMatch, durationMatch, dateTimeMatch, clockMatch, headerMatch, dateTimeMatchDet, struct_match, parseDateTime, isClockLine, parseLine, durationText, generateLine, isHeaderLine, saveTimeData, loadTimeFile, calcFromTo, summarize, listHeaders, main;
  readline = require('readline');
  fs = require('fs');
  os = require('os');
  child_process = require('child_process');
  ref$ = require('prelude-ls'), each = ref$.each, map = ref$.map;
  println = console.log;
  pad2 = function(d){
    if (d < 10) {
      return "0" + d;
    } else {
      return d + "";
    }
  };
  if (!Date.prototype.clockText) {
    Date.prototype.clockText = function(){
      var d;
      d = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][this.getDay()];
      return this.getFullYear() + "-" + pad2(this.getMonth() + 1) + "-" + pad2(this.getDate()) + " " + d + " " + pad2(this.getHours()) + ":" + pad2(this.getMinutes());
    };
  }
  if (!Date.prototype.clockTextDate) {
    Date.prototype.clockTextDate = function(){
      return this.clockText().substring(0, 10);
    };
  }
  startDate = new Date();
  clockfile = process.env.CLOCKFILE;
  backupfile = clockfile + "-" + startDate.clockText().substring(0, 10);
  tmpfile = clockfile + "-" + startDate.clockText().replace(/[^0-9]/g, '');
  dateMatch = /\d{4}-\d{2}-\d{2}/;
  timeMatch = /\d{2}:\d{2}/;
  durationMatch = /-?\d+:\d{2}/;
  dateTimeMatch = new RegExp("(" + dateMatch.source + " [a-z]{2,3} " + timeMatch.source + ")", 'i');
  clockMatch = new RegExp("CLOCK: \\[" + dateTimeMatch.source + "\\](--\\[" + dateTimeMatch.source + "\\]( =>\\s*(" + durationMatch.source + "))?)?", 'i');
  headerMatch = /^(\*+)\s+(.*)$/;
  dateTimeMatchDet = /(\d{4})-(\d{2})-(\d{2}) [a-z]{2,3} (\d{2}):(\d{2})/i;
  struct_match = '^((*+)[[:space:]]+)(.*)$';
  parseDateTime = function(dt){
    var parts;
    if (dt) {
      parts = dt.match(dateTimeMatchDet);
      if (parts) {
        return new Date(parts[1], +parts[2] - 1, parts[3], parts[4], parts[5]);
      }
    }
  };
  isClockLine = function(line){
    var ar, s, e;
    if (ar = line.match(clockMatch)) {
      s = parseDateTime(ar[1]);
      e = parseDateTime(ar[3]);
      return {
        start: s,
        end: e,
        duration: e ? (e - s) / 1000 / 60 : void 8
      };
    }
  };
  parseLine = function(line, deep){
    var h, ar, s, e;
    if (h = line.match(/^(\*+)\s+(.*)$/)) {
      return {
        type: 'header',
        deep: h[1].length,
        header: h[2],
        text: line
      };
    } else if (ar = line.match(clockMatch)) {
      s = parseDateTime(ar[1]);
      e = parseDateTime(ar[3]);
      return {
        type: 'clock',
        start: s,
        end: e,
        duration: e ? (e - s) / 1000 / 60 : void 8,
        text: line,
        deep: deep
      };
    } else {
      return {
        type: 'text',
        text: line
      };
    }
  };
  durationText = function(d){
    var m, ref$;
    m = ((d) % (ref$ = 60) + ref$) % ref$;
    d = d > 0
      ? d - m
      : d + m;
    d = d / 60 + "";
    d = repeatString$(" ", (ref$ = 2 - d.length) > 0 ? ref$ : 0) + d;
    return d + ":" + pad2(m);
  };
  generateLine = function(lineCode){
    var ctxt;
    switch (lineCode.type) {
    case 'header':
      return repeatString$('*', lineCode.deep) + ' ' + lineCode.header;
    case 'clock':
      ctxt = repeatString$(" ", lineCode.deep) + (" CLOCK: [" + lineCode.start.clockText() + "]");
      if (lineCode.end) {
        ctxt = ctxt + ("--[" + lineCode.end.clockText() + "] => " + durationText(lineCode.duration));
      }
      return ctxt;
    default:
      return lineCode.text;
    }
  };
  isHeaderLine = function(line){
    var h;
    return h = line.match(headerMatch);
  };
  saveTimeData = function(data){
    var out;
    println("save-time-data: " + tmpfile);
    if (!fs.existsSync(backupfile)) {
      fs.renameSync(clockfile, backupfile);
      println("Backup created: " + backupfile);
    }
    println("Start writing");
    out = fs.createWriteStream(tmpfile);
    out.on('error', function(it){
      return println("Error: " + it);
    });
    out.on('finish', function(){
      println("Finish event");
      if (fs.existsSync(clockfile)) {
        return fs.unlink(clockfile, function(err){
          if (err) {
            println("** Could not remove " + clockfile);
            process.exit(1);
          }
          fs.renameSync(tmpfile, clockfile);
          return println("All written");
        });
      } else {
        return fs.renameSync(tmpfile, clockfile);
      }
    });
    each(function(it){
      out.write(generateLine(it) + "\n");
    }, data);
    println("Finished writing");
    return out.end();
  };
  loadTimeFile = function(cb, params){
    var currentDeep, fileData, rd;
    if (!clockfile || !fs.existsSync(clockfile)) {
      println("You need to set the environment variable CLOCKFILE (pointing to an existing file)");
      process.exit(1);
    }
    currentDeep = 0;
    fileData = [];
    rd = readline.createInterface({
      input: fs.createReadStream(clockfile),
      output: process.stdout,
      terminal: false
    });
    rd.on('line', function(line){
      var l;
      l = parseLine(line, currentDeep);
      fileData.push(l);
      if (l.deep) {
        currentDeep = l.deep;
      }
    });
    rd.on('close', function(){
      cb(fileData, params);
    });
  };
  calcFromTo = function(dateFilter){
    var filterText, ref$, y, m, d, mod, y1, y2, m1, m2, d1, d2;
    filterText = dateFilter[0];
    ref$ = [startDate.getFullYear(), startDate.getMonth(), startDate.getDate()], y = ref$[0], m = ref$[1], d = ref$[2];
    mod = 0;
    ref$ = (function(){
      switch (filterText) {
      case 'today':
        return [y, y, m, m, d + mod, d + mod + 1];
      case 'thismonth':
        return [y, y, m + mod, m + mod + 1, 1, 1];
      case 'lastmonth':
        return [y, y, m + mod - 1, m + mod, 1, 1];
      case 'thisyear':
        return [y + mod, y + mod + 1, 0, 0, 1, 1];
      case 'lastyear':
        return [y + mod - 1, y + mod, 0, 0, 1, 1];
      default:
        return [0, 3000, 0, 0, 1, 1];
      }
    }()), y1 = ref$[0], y2 = ref$[1], m1 = ref$[2], m2 = ref$[3], d1 = ref$[4], d2 = ref$[5];
    return [new Date(y1, m1, d1), new Date(y2, m2, d2)];
  };
  summarize = function(data, dateFilter){
    var lastHeader, ref$, fFrom, fTo, i$, len$, l;
    ref$ = calcFromTo(dateFilter), fFrom = ref$[0], fTo = ref$[1];
    data[0].info = fFrom.clockTextDate() + " -- " + fTo.clockTextDate();
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      l = data[i$];
      if (l.duration && l.start >= fFrom && l.start < fTo) {
        lastHeader.sum += l.duration;
      }
      if (l.type === 'header') {
        lastHeader = l;
        lastHeader.sum = 0;
      }
    }
  };
  listHeaders = function(data, dateFilter){
    var i$, len$, l;
    summarize(data, dateFilter);
    println(data[0].info);
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      l = data[i$];
      if (l.type === 'header') {
        println(repeatString$('*', l.deep) + (" " + l.header) + (l.sum && l.sum > 0 ? " [" + durationText(l.sum) + "]" : ""));
      }
    }
  };
  /* ********************************** */
  main = function(argv){
    var cmd, child;
    argv.shift();
    argv.shift();
    cmd = argv.shift();
    switch (cmd) {
    case 'diff':
      child = child_process.spawn('gvimdiff', [clockfile, backupfile], {
        detached: true
      });
      child.on('close', function(){
        return println("command ended");
      });
      return println(argv);
    case 'ls':
      return loadTimeFile(listHeaders, argv);
    case 'rewrite':
      return loadTimeFile(saveTimeData);
    default:
      return println("Usage: punch <cmd> {<options>}*");
    }
  };
  main(process.argv);
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);
