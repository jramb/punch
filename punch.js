// Generated by LiveScript 1.2.0
/* 2014 by J Ramb */
(function(){
  var readline, fs, os, child_process, println, pad2, startDate, config, dateMatch, timeMatch, durationMatch, dateTimeMatch, clockMatch, headerMatch, dateTimeMatchDet, parseDateTime, parseLine, durationText, generateLine, closeClockLine, saveTimeData, loadTimeFile, calcFromTo, summarize, listHeaders, closeAll, closeAllTimes, checkIn, prompt, main;
  readline = require('readline');
  fs = require('fs');
  os = require('os');
  child_process = require('child_process');
  println = console.log;
  pad2 = function(d){
    if (d < 10) {
      return "0" + d;
    } else {
      return d + "";
    }
  };
  if (!Date.prototype.clockText) {
    Date.prototype.clockText = function(){
      var d;
      d = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][this.getDay()];
      return this.getFullYear() + "-" + pad2(this.getMonth() + 1) + "-" + pad2(this.getDate()) + " " + d + " " + pad2(this.getHours()) + ":" + pad2(this.getMinutes());
    };
  }
  if (!Date.prototype.clockTextDate) {
    Date.prototype.clockTextDate = function(){
      return this.clockText().substring(0, 10);
    };
  }
  if (!Date.prototype.getMonDay) {
    Date.prototype.getMonDay = function(){
      var day;
      day = this.getDay() - 1;
      if (day < 0) {
        return 6;
      } else {
        return day;
      }
    };
  }
  startDate = new Date();
  config = {
    clockfile: process.env.CLOCKFILE,
    backupfile: "-" + startDate.clockText().substring(0, 10)
  };
  (function(configFile){
    var that, configFIXME;
    if (fs.existsSync(configFile)) {
      if (that = fs.readFileSync('punch.json')) {
        configFIXME = JSON.parse(that);
      }
    }
  }.call(this, 'punch.json'));
  dateMatch = /\d{4}-\d{2}-\d{2}/;
  timeMatch = /\d{2}:\d{2}/;
  durationMatch = /-?\d+:\d{2}/;
  dateTimeMatch = new RegExp("(" + dateMatch.source + " [a-z]{2,3} " + timeMatch.source + ")", 'i');
  clockMatch = new RegExp("CLOCK: \\[" + dateTimeMatch.source + "\\](--\\[" + dateTimeMatch.source + "\\]( =>\\s*(" + durationMatch.source + "))?)?", 'i');
  headerMatch = /^(\*+)\s+(.*)$/;
  dateTimeMatchDet = /(\d{4})-(\d{2})-(\d{2}) [a-z]{2,3} (\d{2}):(\d{2})/i;
  parseDateTime = function(dt){
    var parts;
    if (dt) {
      parts = dt.match(dateTimeMatchDet);
      if (parts) {
        return new Date(parts[1], +parts[2] - 1, parts[3], parts[4], parts[5]);
      }
    }
  };
  parseLine = function(line, deep){
    var h, ar, s, e;
    if (h = line.match(/^(\*+)\s+(.*)$/)) {
      return {
        type: 'header',
        deep: h[1].length,
        header: h[2],
        text: line
      };
    } else if (ar = line.match(clockMatch)) {
      s = parseDateTime(ar[1]);
      e = parseDateTime(ar[3]);
      return {
        type: 'clock',
        start: s,
        end: e,
        duration: e ? (e - s) / 1000 / 60 : void 8,
        text: line,
        deep: deep
      };
    } else {
      return {
        type: 'text',
        text: line
      };
    }
  };
  durationText = function(d){
    var m, ref$;
    m = ((d) % (ref$ = 60) + ref$) % ref$;
    d = d > 0
      ? d - m
      : d + m;
    d = d / 60 + "";
    d = repeatString$(" ", (ref$ = 2 - d.length) > 0 ? ref$ : 0) + d;
    return d + ":" + pad2(m);
  };
  generateLine = function(lineCode){
    var ctxt;
    switch (lineCode.type) {
    case 'header':
      return repeatString$('*', lineCode.deep) + ' ' + lineCode.header;
    case 'clock':
      ctxt = repeatString$(" ", lineCode.deep) + (" CLOCK: [" + lineCode.start.clockText() + "]");
      if (lineCode.end) {
        ctxt = ctxt + ("--[" + lineCode.end.clockText() + "] => " + durationText(lineCode.duration));
      }
      return ctxt;
    default:
      return lineCode.text;
    }
  };
  closeClockLine = function(line){
    if (!(line.start && !line.end)) {
      throw new Error("line " + line + " not a clock line or not open!");
    }
    line.end = startDate;
    line.end.setMilliseconds(0);
    line.end.setSeconds(0);
    return line.duration = (line.end - line.start) / 1000 / 60;
  };
  saveTimeData = function(data){
    var clockfile, backupfile, tmpfile, out, i$, len$, it;
    clockfile = config.clockfile;
    backupfile = clockfile + config.backupfile;
    tmpfile = clockfile + ("-" + startDate.clockText().replace(/[^0-9]/g, ''));
    if (!fs.existsSync(backupfile)) {
      fs.renameSync(clockfile, backupfile);
    }
    out = fs.createWriteStream(tmpfile);
    out.on('error', function(it){
      println("Error: " + it);
      return process.exit(1);
    });
    out.on('finish', function(){
      if (fs.existsSync(clockfile)) {
        return fs.unlink(clockfile, function(err){
          if (err) {
            println("** Could not remove " + clockfile);
            process.exit(1);
          }
          return fs.renameSync(tmpfile, clockfile);
        });
      } else {
        return fs.renameSync(tmpfile, clockfile);
      }
    });
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      it = data[i$];
      out.write(generateLine(it) + "\n");
    }
    return out.end();
  };
  loadTimeFile = function(cb, params){
    var clockfile, currentDeep, fileData, rd;
    clockfile = config.clockfile;
    if (!clockfile || !fs.existsSync(clockfile)) {
      println("You need to set the environment variable CLOCKFILE (pointing to an existing file)");
      process.exit(1);
    }
    currentDeep = 0;
    fileData = [];
    rd = readline.createInterface({
      input: fs.createReadStream(clockfile),
      output: process.stdout,
      terminal: false
    });
    rd.on('line', function(line){
      var l;
      l = parseLine(line, currentDeep);
      fileData.push(l);
      if (l.deep) {
        currentDeep = l.deep;
      }
    });
    rd.on('close', function(){
      cb(fileData, params);
    });
  };
  calcFromTo = function(dateFilter){
    var mtch, pre, unit, mod, ref$, y, m, d, y1, y2, m1, m2, d1, d2;
    if (dateFilter[0]) {
      mtch = dateFilter[0].match(/^(this|last)?(month|week|year|today|all)([+-]\d+)?$/i);
      if (mtch) {
        pre = mtch[1], unit = mtch[2], mod = mtch[3];
      }
    }
    pre == null && (pre = 'this');
    unit == null && (unit = 'month');
    mod == null && (mod = 0);
    mod = +mod;
    if (pre === "last") {
      mod -= 1;
    }
    ref$ = [startDate.getFullYear(), startDate.getMonth(), startDate.getDate()], y = ref$[0], m = ref$[1], d = ref$[2];
    ref$ = (function(){
      switch (unit.toLowerCase()) {
      case 'today':
        return [y, y, m, m, d + mod, d + mod + 1];
      case 'week':
        d - startDate.getMonDay();
        return [y, y, m, m, d + mod * 7, d + (mod + 1) * 7];
      case 'month':
        return [y, y, m + mod, m + mod + 1, 1, 1];
      case 'year':
        return [y + mod, y + mod + 1, 0, 0, 1, 1];
      default:
        return [0, 3000, 0, 0, 1, 1];
      }
    }()), y1 = ref$[0], y2 = ref$[1], m1 = ref$[2], m2 = ref$[3], d1 = ref$[4], d2 = ref$[5];
    return [new Date(y1, m1, d1), new Date(y2, m2, d2)];
  };
  summarize = function(data, dateFilter){
    var lastHeader, ref$, fFrom, fTo, fToShow, i$, len$, l;
    ref$ = calcFromTo(dateFilter), fFrom = ref$[0], fTo = ref$[1];
    fToShow = new Date(fTo);
    fToShow.setDate(fTo.getDate() - 1);
    data[0].info = fFrom.clockTextDate() + " -- " + fToShow.clockTextDate();
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      l = data[i$];
      if (l.duration && l.start >= fFrom && l.start < fTo) {
        lastHeader.sum += l.duration;
      }
      if (l.type === 'header') {
        lastHeader = l;
        lastHeader.sum = 0;
      }
    }
  };
  listHeaders = function(data, dateFilter){
    var i$, len$, l;
    summarize(data, dateFilter);
    println(data[0].info);
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      l = data[i$];
      if (l.type === 'header' && l.sum > 0) {
        println(repeatString$('*', l.deep) + (" " + l.header) + (l.sum && l.sum > 0 ? " [" + durationText(l.sum) + "]" : ""));
      }
    }
  };
  closeAll = function(data){
    var lastHeader, i$, len$, l;
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      l = data[i$];
      if (l.type === 'header') {
        lastHeader = l;
      }
      if (l.type === 'clock' && !l.end) {
        data[0].modified = true;
        closeClockLine(l);
        println(lastHeader.text + " checked out: " + durationText(l.duration));
        println(generateLine(l) + "");
      }
    }
  };
  closeAllTimes = function(data, params){
    closeAll(data);
    if (data[0].modified) {
      saveTimeData(data);
    }
  };
  checkIn = function(data, params){
    var foundIdx, found, headerLike, i$, len$, idx, l, openLine;
    found = 0;
    if (!params[0]) {
      println("Need a header (or part of it) to check in");
      process.exit(1);
    }
    headerLike = new RegExp(params[0], "i");
    closeAll(data);
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      idx = i$;
      l = data[i$];
      if (l.type === 'header' && l.text.match(headerLike)) {
        found++;
        println(l.text);
        foundIdx = idx;
      }
    }
    if (found === 0) {
      println("Found no matching header for " + params[0]);
    } else if (found > 1) {
      println("Found too many matching headers for " + params[0]);
    } else {
      openLine = {
        type: 'clock',
        start: startDate,
        deep: data[foundIdx].deep
      };
      data.splice(foundIdx + 1, 0, openLine);
      data[0].modified = true;
      println(generateLine(openLine) + " CHECKED IN");
      if (data[0].modified) {
        saveTimeData(data);
      }
    }
  };
  prompt = function(data, params){
    var lastHeader, i$, len$, l;
    for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
      l = data[i$];
      if (l.type === 'header') {
        lastHeader = l;
      }
      if (l.type === 'clock' && !l.end) {
        closeClockLine(l);
        println(lastHeader.header + ": " + durationText(l.duration) + "\\n");
      }
    }
  };
  /* ********************************** */
  main = function(argv){
    var cmd, backupfile, child;
    argv.shift();
    argv.shift();
    cmd = argv.shift();
    switch (cmd) {
    case 'diff':
      backupfile = config.clockfile + config.backupfile;
      if (fs.existsSync(backupfile)) {
        child = child_process.spawn('gvimdiff', [config.clockfile, backupfile], {
          detached: true
        });
        return child.on('close', function(){
          return println("command ended");
        });
      } else {
        child = child_process.spawn('gvim', [config.clockfile], {
          detached: true
        });
        return child.on('close', function(){
          return println("command ended");
        });
      }
      break;
    case 'ls':
    case 'show':
      return loadTimeFile(listHeaders, argv);
    case 'rewrite':
      return loadTimeFile(saveTimeData, argv);
    case 'out':
      return loadTimeFile(closeAllTimes, argv);
    case 'in':
      return loadTimeFile(checkIn, argv);
    case 'pro':
    case 'prompt':
      return loadTimeFile(prompt, argv);
    case 'ru':
    case 'running':
      return loadTimeFile(prompt, argv);
    default:
      return println("'punch' 2014 by jramb\n---------------------\nUsage: punch <command> {<opt>, ...}\n\ncommands:\n  h[elp]      Show this message\n  ls / show   lists tasks in clock filej\n  in <task>   Check in (start timer) for task (also stops all other timers)\n  out         Check out (stops ALL timers)\n\nYou need to set the environment variable CLOCKFILE (pointing to an existing file)");
    }
  };
  main(process.argv);
  function repeatString$(str, n){
    for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
    return r;
  }
}).call(this);
